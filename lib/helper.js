// Helper function that turns a function into curried form
function curry(fn){
    let arity = fn.length;
    function worker(f,ar){
        if(ar == 1){return f}
        return worker((...args) => {return (x)=>f(...args.slice(0,ar),x)},ar-1)
    }
    return worker(fn, arity)
}

// multiplay two 3x3 matrix stored in column major order
// auto generated by github co-pilot, need verification
function matmul(A, B){
    var C = new Array(9);
    for(var i = 0; i < 3; i++){
        for(var j = 0; j < 3; j++){
            C[i*3+j] = 0;
            for(var k = 0; k < 3; k++){
                C[i*3+j] += A[i*3+k] * B[k*3+j];
            }
        }
    }
    return C;
}

// clamp the num in [min, max]
function clamp(num, min, max) {
    num = Math.max(num, min)
    num = Math.min(num, max)

    return num
}

var t
function pointNode(x, y, color="red"){
    var point = new Node(`point({x}-{y})`,false);
    t = point
    point.state.x = x;
    point.state.y = y;
    point.drawSelf = function(){
        fill(color);
        noStroke();
        ellipse(0,0, 10, 10);
    }
    point.setTranslate(x, y);
    return point;
}

function mouseTracker(){
    var backmask = new SizeNode("backmask", windowWidth, windowHeight,true, true);
    var arrow = new Node("mouse_tracker",false);

    backmask.updateSelf = function(){
        this.setSize(windowWidth, windowHeight);
    }
    
    backmask.onMousePress = function(){
        arrow.state.start = [mouseX, mouseY];
        arrow.state.end = [mouseX, mouseY];
        arrow.show();
    }
    backmask.onMouseRelease = function(){
        arrow.hide();
    }
    backmask.onMouseDrag = function(self, currentPos, startPos){
        arrow.state.end = currentPos;
    }
    arrow.state.start = [0,0]
    arrow.state.end = [200,200]
    arrow.drawSelf = function(){
        const d = dist(this.state.start[0], this.state.start[1], this.state.end[0], this.state.end[1]);
        stroke(255,0,0,200);
        strokeWeight(3);
        line(this.state.start[0], this.state.start[1], ...this.state.end);
        
        push();
        noStroke();
        fill(255,0,0,200);
        translate(this.state.end[0], this.state.end[1]);
        var theta = atan2(this.state.end[1]-this.state.start[1], this.state.end[0]-this.state.start[0])
        rotate(theta);
        triangle(4, 0, -10, 10, -10, -10);
        pop();

        push();
        fill(255,0,0,200);
        stroke(255,0,0,200);
        textSize(max(20,d/20));
        rectMode(CENTER);
        difference = [this.state.end[0]-this.state.start[0], this.state.end[1]-this.state.start[1]];
        textPos = [this.state.start[0]+difference[0]*0.1, this.state.start[1]+difference[1]*0.1];
        translate(...textPos)
        rotate(theta)
        text("("+difference.toString()+")", 0,0);
        pop();
    } 
    arrow.hide();
    
    backmask.addChild(arrow);
    return backmask;
    //arrow.hide();

}

function pulse(low=0, high=1, period=1000, duty=0.5, sharpness=0.1){
    const p_func = function(x){
        x = x % (period*2)
        const e = ((x / period) - (1-duty/2)) / sharpness
        const t = exp(-e*e)
        const y = low + t * (high - low)
        return y
    }
    return p_func
}

function cursor_pointer(){
    document.body.style.cursor = "pointer";
}

function cursor_default(){
    document.body.style.cursor = "default";
}


//default_font = new FontFace('openhuninn', 'jf-openhuninn-1.1/jf-openhuninn-1.1.ttf')
function textNode(text, x, y, fontSize, font="openhuninn", w_ele=10, h_ele=2){
    p = createP(text);
    p.style('font-size', fontSize+"px");
    p.style('font-family', font);
    p.position(x, y);
    p.style('width', w_ele+"em");
    p.style('height', h_ele+"em");
    p.style('line-height', 1+"em");
    p.style('overflow', 'hidden');
    return p
}

/** This file defines Scene, Node and SceneManager classes. 
 *  
 *  Node is a container for objects on the scene
 *  Node can be a container for other nodes
 *  Node can be a leaf node (e.g. a picture / shape / text)
 *  
 *  Scene is a extension of Node
 *  Scene wraps around all needed Nodes in a game stage or animation scene.
 *  The Nodes are organized in a tree structure.
 *  The root node is the scene itself.
 *  
 *  SceneManager is a singleton class that manages the scenes.
 *  It is responsible for managing the scenes.
 *  Anyone can create and register a scene to the scene manager
 *  After Registration, the creater should remove its own reference to the scene
 *  The scene manager will take care of the scene's life cycle. 
 *  
 *  The scene is hidden when it first registered.
 *  The scene can request to be shown by calling self.Show()
 *  The scene can request to be hidden by calling self.Hide()
 *  The scene can request to be removed by calling self.Remove()
 *  
 *  The communication between scenes done by subscribing to topics
 *  I use implemetation here (https://github.com/mroderick/PubSubJS) 
 *  because it defaults to asynchronous semantics, which avoid unexpected blocking behavior when message handeler publish another message. 
 *  
 * 
 *  @author BO-YU Cheng <nemo1999.eecs06@g2.nctu.edu.tw>
 *  @version 0.0.1   2022/04/08
 **/

// Helper function that turns a function into curry form
function curry(fn){
    let arity = fn.length;
    function worker(f,ar){
        if(ar == 1){return f}
        return worker((...args) => {return (x)=>f(...args.slice(0,ar),x)},ar-1)
    }
    return worker(fn, arity)
}

// multiplay two 3x3 matrix stored in column major order
// auto generated by github co-pilot, need verification
function matmul(A, B){
    var C = new Array(9);
    for(var i = 0; i < 3; i++){
        for(var j = 0; j < 3; j++){
            C[i*3+j] = 0;
            for(var k = 0; k < 3; k++){
                C[i*3+j] += A[i*3+k] * B[k*3+j];
            }
        }
    }
    return C;
}

class Node{
    constructor(params){
        // transforms
        this.theta = 0;
        this.scale = 1;
        this.translation = [0,0]
        this.additional_transforms = [];

        // children
        // Note that all children will be affected by the transforms of the parent
        this.children = []; // the cildren will be drawn in the order of this array

        // state
        this.visible = true; // if true,  render() will be called at each frame
        this.active = true; //  if true,  update() will be called at each frame

        // time control (milliseconds)
        this.acc_t = 0; // accumulated time since object creation
        this.del_t = 0; // time since last update
        
        // callbacks handeling 
        this.subcriptions = []; // each element contains {topic: t, token: k, callback: c}

        // deleteing self
    }

    update(deltaT){
        this.acc_t += deltaT;
        this.del_t = deltaT;
        this.update_self(); // implement in child class
    }
    render(){
        push();
        // apply transforms
        rotate(this.theta);
        scale(this.scale);
        translate(...this.translation)
        for(t of this.additional_transforms){
            t();
        }
        // render self
        this.draw_self(); // implement in child class

        // render children
        for(ch of this.children){
            ch.updata(deltaT)
            ch.render()
        }
        // restore transforms
        pop();
    }
    
    update_self(){

    }
    
    draw_self(){

    }
    // the callback will be passed the object reference as additional argument
    subscribe(topic, callback){
        var token = PubSub.subscribe(topic, callback);
    }
    clear_transform(){
        this.additional_transforms = [];
    }
    apply_transform(t){
        this.additional_transforms.push(t);
    }
    rotate(theta){
        this.theta = theta;
    }
    scale(scale){
        this.scale = scale;
    }
    translate(x,y){
        this.translate = [x,y]
    }
    
}





